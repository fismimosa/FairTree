import numpy as npimport randomfrom multiprocessing import Managerfrom competitors.Competitors.algorithmic_fairness.SOTA.Variational_Fair_Clustering.Kmeans_Kmedian.src.fair_clustering import \    fair_clusteringclass VFC_model():    def __init__(self, K, lmbda = 10 , fairness = True, cluster_option = 'kmeans',                 cluster_initialization = 'kmeans_plus', seed_value=42, min_max_scaled = True):        """Initialize the VFC_ziko model with a random seed and result storage."""        self.seed = seed_value        self.list_obj_K = []        # Stores objective costs over different K values        self.list_balance_K = []    # Stores balance measures over different K values        self.list_centroids_K = []  # Stores centroids for different K values        self.K = K        self.lmbda = lmbda        self.fairness = fairness        self.cluster_option = cluster_option        self.cluster_initialization = cluster_initialization        self.k_centroid = None        self.min_max_scaled = min_max_scaled    def predict(self, X, training_set = True):        """Predicts the X labels        Args:            X as numpy array                    """        #assume we are working with the training set directly        if training_set:            return np.array(self.labels_training)        return None        #return self.assign_to_nearest_centroid(X, self.list_centroids_K)            def fit(self, X):                """Fits the model using the given parameters.        Args:            X (numpy array): Does contain the protected attribute but does not contain the target class/y            K (int): Number of clusters.            lmbda (int) : lmbda value for function to optimize            protected_attr_list (list):    protected attribute.            target_variable_list (list): target variable.            verbose (bool): Whether to print debug information.            iterations (int): Number of iterations for clustering.            option (str): Clustering algorithm to use ('Kmeans' or other).        """        # Set random seed        np.random.seed(self.seed)        random.seed(self.seed)        if self.min_max_scaled:            ##if MinMax has been used, add 1 to avoid possible division by 0            X = X + 1        demograph = X[:, 0].flatten()        unique_demograph = np.unique(demograph)        V_list = [np.array(demograph == j) for j in unique_demograph]        N = len(demograph)        V_sum = [v.sum() for v in V_list]        u_V = [x / N for x in V_sum]                manager = Manager()        SHARED_VARS = manager.dict()                seedValue = self.seed        C, l, elapsed, S, E = fair_clustering(SHARED_VARS, X, self.K, u_V, V_list, seedValue, self.lmbda, self.fairness,                                              self.cluster_option, self.cluster_initialization)        self.list_centroids_K = C        self.labels_training = l        return self                                            